{"ast":null,"code":"import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\"\n    });\n  }\n  return dtfCache[zone];\n}\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6\n};\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const {\n      type,\n      value\n    } = formatted[i];\n    const pos = typeToPos[type];\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", {\n        timeZone: zone\n      }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, {\n    format,\n    locale\n  }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts);\n    if (isNaN(date)) return NaN;\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0\n    });\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}","map":{"version":3,"names":["formatOffset","parseZoneInfo","isUndefined","objToLocalTS","Zone","dtfCache","makeDTF","zone","Intl","DateTimeFormat","hour12","timeZone","year","month","day","hour","minute","second","era","typeToPos","hackyOffset","dtf","date","formatted","format","replace","parsed","exec","fMonth","fDay","fYear","fadOrBc","fHour","fMinute","fSecond","partsOffset","formatToParts","filled","i","length","type","value","pos","parseInt","ianaZoneCache","IANAZone","create","name","resetCache","isValidSpecifier","s","isValidZone","e","constructor","zoneName","valid","isUniversal","offsetName","ts","locale","offset","Date","isNaN","NaN","adOrBc","Math","abs","adjustedHour","asUTC","millisecond","asTS","over","equals","otherZone","isValid"],"sources":["C:/Users/M1503/Documents/PROYECTOS/LoggroFront/node_modules/luxon/src/zones/IANAZone.js"],"sourcesContent":["import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n  }\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}